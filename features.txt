any.toString() -> String

number.fix(digits: Number) -> String    // 100.fix(2) => '100.00'

string.reverse() -> String
string.toUpper(section?: Range) -> String
string.toLower(section?: Range) -> String
string.toTitle() -> String
string.replace(searcher: RegExp | String | Function, replacer: String | Function) -> String
string.at(index: Number, default?)
string.match(rex: RegExp) -> String[]
string.startsWith(value: String) -> Boolean
string.endsWith(value: String) -> Boolean
string.indexOf(value: String) -> Number
string.pad(size: Number, fillText: String)
string.padStart(size: Number, fillText := ' ')
string.padEnd(size: Number, fillText := ' ')
string.trim()
string.trimStart()
string.trimEnd()
string.codeAt(index: Number) -> Number
string.reverse() -> String
string.randomChar(range?: Range) -> String

regexp.matches(text: String) -> Boolean
regexp.flags: String
regexp.body: String

Object.toString(value) -> String
object.get(name: String, default?)
object.set(name: String, value) -> Void
object.has(name: String) -> Boolean
object.allKeys() -> String[]
object.allValues() -> Any[]

array.at(index: Number, default?)
array.set(index: Number, value) -> Void
array.section((start, end, step = 1)?: Number) -> Array
array.append(value)
array.preppend(value)
array.remove(index)
array.insert(index, value)
array.filter(cb: (element, index, array) -> Boolean)
array.reduce(cb: fun (prev, curr, index, array), default)
array.indexOf(value) -> Number
array.flat(depth: Number)
array.join(joiner: String) -> String
array.reverse()
array.sort(cb?)
array.randomItem(range?: Range)

function.name: String
function.arguments: Function.Argument[]


error.name: String = this.__ctor.name    // TypeError { name: 'TypeError' }
error.description?: String
error.stack?: String

class Error {
	getter name => this.__ctor.name
	description: str later
	toString! => description? name : '$name: $description'
}




if () {} or () {} else {}
unless () {} or () {} else {}

switch () as () { // switch es una expresion igual que una ternaria,
                  // segun el contexto return va a funcionar de diferentes maneras
	() {}
	is () {}
	else {}
}

loop {
	break
	skip
}
while () {}
until () {}
for () in () {}
for () of () {}

try {} catch (): () {}
/* try {} catch: () */    // catch: printerr

... then () {}

import () as () from ()

(): () = ()
const (): () = ()
(): () later

fun ()(()) -> () {
	ret ()
}

(()) -> () => {}

class () extends () {
	priv ()
	public ()    // solo sobreescribiendo, si no se lanza una advertencia
	static ()
	()(()) {}    // __ctor() {}
}

type () = ()
type () {}

() and ()
() or ()
not ()
() in ()
throw ()
del ()

(()) ()    // (str) 123 -> '123'

write(values, sep, end)
print(values, sep, end)
read()
typeof(value) -> str
sizeof(value) -> num
isempty(value) -> bool
exit(code)
eval(string)
isinstance(value, ctor)
isparent(ctor, master)
/* promise(function: fun (resolve, reject)) */

math.random(0 ~ 100) |> print(a, it, b)

await fetch('https://books.com/')
	then res:
		res.json()
	then json:
		return json.books

